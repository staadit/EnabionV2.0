# R1.0 Decisions: Email Intake, Mutual NDA Copy, and Attachment Storage (MVP)

Status: **CTO decision / binding for R1.0**
Date: 2025-12-15 (CET)

This document resolves three open implementation questions for Enabion R1.0:

1. Email intake: mock/API vs real inbound email (MX).
2. Mutual NDA copy: source, languages, and acceptance/audit semantics.
3. Attachment storage: local filesystem vs S3-compatible object storage for MVP.

This is meant to unblock implementation (G2/G3/G4/G7/G8) and CI/telemetry work.

---

## 1) Email intake (G3) — approach

### 1.1 R1.0 decision
**R1.0 will support two modes of email intake:**

- **Mode A (DEV/CI/STAGE): Mock/API intake (no MX required).**
  - Used for local dev, CI, seed data, and deterministic tests.
  - Implemented as an authenticated API endpoint that accepts raw RFC822 or a simplified JSON payload.

- **Mode B (PILOT/PROD): Real inbound email via a managed inbound email provider + webhook (MX required, but not self-hosted).**
  - We do **not** self-host SMTP on the VPS.
  - We configure MX for a *single inbound subdomain* and route inbound mail to the API via provider webhooks.

This preserves product value (“email → intent”) while keeping infrastructure light and secure.

### 1.2 Addressing scheme (org routing without per-org MX)
To avoid per-organization MX/subdomain complexity, R1.0 uses **plus-addressing**:

- Canonical inbound domain: `intake.enabion.com`
- Per-org inbox: `intent+{orgSlug}@intake.enabion.com`

Examples:
- `intent+acme@intake.enabion.com`
- `intent+brightcode@intake.enabion.com`

In UI we present the org-specific address as the “Forward-to” email.

> Note: If later we want `intent@{orgSlug}.enabion.com`, that can be an R1.1+ enhancement. R1.0 is plus-addressing only.

### 1.3 Provider choice (implementation guideline)
Any provider supporting inbound email parsing + webhook works (Mailgun, Postmark, SendGrid Inbound Parse, SES+Lambda, etc.).

**Default recommendation for R1.0:** Mailgun Inbound Routes (fast setup, good docs).  
Provider credentials must be stored in **GitHub Actions Secrets** and VPS env; never committed.

### 1.4 Intake payload requirements
Minimum fields we must extract/store:

- `messageId` (Message-ID)
- `threadId` (derived using `In-Reply-To` / `References`)
- `from`, `to`, `cc`
- `subject`, `textBody`, `htmlBody` (store textBody; htmlBody optional)
- `receivedAt`
- attachments (metadata + blob references)

### 1.5 Idempotency & threading
- Idempotency key: `(orgId, messageId)` must be unique.
- Thread linking:
  1) If `In-Reply-To` present → link to referenced messageId.
  2) Else if `References` present → link to last reference.
  3) Else → new thread.

### 1.6 Failure modes
- If parsing fails: store the raw email safely (encrypted blob) and emit `EMAIL_PARSE_FAILED` with reason.
- If orgSlug not recognized: emit `EMAIL_ORG_RESOLUTION_FAILED` and quarantine.

---

## 2) Mutual NDA copy (G4) — source, languages, and acceptance semantics

### 2.1 R1.0 decision
- **Canonical legal text language:** **EN** (single source of truth).
- **User-facing languages:** PL/DE/NL + EN UI. For the NDA:
  - Provide **localized short summary** (PL/DE/NL/EN) for comprehension.
  - Optionally provide full-text translations, but **EN prevails** in case of discrepancy.

Rationale: R1.0 needs a workable legal gating mechanism without blocking progress on full legal localization.

### 2.2 Source & storage of NDA text
- The Mutual NDA is stored in repo as a versioned file:
  - `docs/R1.0/legal/nda/mutual_nda_v0.1_en.md` (canonical)
  - Optional:
    - `mutual_nda_v0.1_pl.md`
    - `mutual_nda_v0.1_de.md`
    - `mutual_nda_v0.1_nl.md`
- The app renders markdown to HTML for reading; PDF export optional.

### 2.3 Acceptance UX (click-to-accept)
R1.0 acceptance mechanism:
- Checkbox: “I accept the Enabion Mutual NDA vX.Y”
- Typed name (or “Full name”) + role title (free text)
- Accept/Cancel
- Must be authenticated session.
- Emit `NDA_ACCEPTED`.

### 2.4 Acceptance audit record (must store)
Store, per org-pair (X↔Y), per NDA version:
- `ndaVersion`
- `ndaTextSha256` of canonical EN markdown (or rendered canonical text)
- `acceptedByUserId`, `acceptedByOrgId`
- `counterpartyOrgId`
- `acceptedAt`
- `ipAddress` (best-effort), `userAgent` (best-effort)
- `acceptedLocale` (PL/DE/NL/EN)

This enables non-repudiation and later dispute support.

---

## 3) Attachment storage (G3/G7/G8) — local vs S3-compatible

### 3.1 R1.0 decision (MVP)
Implement a **BlobStore abstraction** with two drivers:

- **Driver 1: Local filesystem** (default for DEV/CI/STAGE)
  - Use Docker volume persistence (`/data/blobs`) for local runs.
- **Driver 2: S3-compatible object storage** (recommended for PILOT/PROD)
  - Examples: Cloudflare R2, Backblaze B2 (S3 API), AWS S3, MinIO (only if needed).
  - Keeps VPS lean and simplifies backups.

If S3 is not available for the pilot, we can run prod using local volume, but **S3 is preferred**.

### 3.2 Security: encryption at rest (application-level)
Regardless of driver, R1.0 must support **application-level encryption** for attachment bytes:

- Encrypt bytes with AES-256-GCM before storing.
- Store `keyId`, `nonce`, `ciphertext` metadata.
- Key material is provided via environment variables (rotatable).
- Never commit encryption keys to repo.

### 3.3 File constraints (MVP)
- Allowed types: `pdf`, `txt`, `md`, `docx` (no executables).
- Max size: 10 MB per attachment (configurable).
- Virus scanning: out of scope for R1.0; mitigate by file type limits + size limits.

### 3.4 Metadata model
Store attachment metadata in Postgres (always), bytes in BlobStore:
- `blobId` (uuid)
- `orgId`
- `intentId` / `messageId` (subject reference)
- `filename`, `contentType`, `sizeBytes`
- `storageDriver`, `storageKey`
- `encryptionKeyId`, `encryptionNonce`
- `createdAt`, `deletedAt`

### 3.5 Retention interaction
- Soft delete marks metadata as deleted and prevents retrieval.
- Purge deletes ciphertext from storage and removes/obfuscates sensitive content references.

---

## 4) Environment variables (baseline)

### 4.1 Email intake
- `EMAIL_INTAKE_MODE=mock|provider`
- `EMAIL_INTAKE_DOMAIN=intake.enabion.com`
- Provider-specific (example):
  - `MAILGUN_API_KEY=...`
  - `MAILGUN_SIGNING_KEY=...` (for webhook signature verification)

### 4.2 BlobStore
- `BLOB_DRIVER=local|s3`
- Local:
  - `BLOB_LOCAL_ROOT=/data/blobs`
- S3:
  - `BLOB_S3_ENDPOINT=...`
  - `BLOB_S3_REGION=...`
  - `BLOB_S3_BUCKET=...`
  - `BLOB_S3_ACCESS_KEY=...`
  - `BLOB_S3_SECRET_KEY=...`

### 4.3 Encryption
- `BLOB_ENCRYPTION_KEY_CURRENT=...`
- `BLOB_ENCRYPTION_KEY_PREVIOUS=...` (optional for rotation)

---

## 5) Required GH issues (if not already present)
- `R1.0-EMAIL-INGEST-API` (mock intake endpoint + CI usage)
- `R1.0-EMAIL-PROVIDER-SETUP` (MX + webhook + signature verification)
- `R1.0-NDA-TEXT-001` (mutual NDA canonical EN + localized summaries)
- `R1.0-BLOBSTORE-001` (drivers + encryption + metadata model)

---
